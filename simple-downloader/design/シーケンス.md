# シーケンス
## 図① 正常ダウンロード（初期化〜完了〜RAII）
4つのフェーズで構成されます。
初期化フェーズでは Downloader 生成時に curl_global_init() がプロセス全体で1回だけ呼ばれます。addObserver() は複数回呼べます。
startDownload フェーズでは呼び出し元スレッドがブロックしないよう、即座に std::thread を起動して true を返します。このため UI スレッドから安全に呼べます。
ダウンロードループがこの実装の核心で、curl のコールバックが鎖状に連携します。progressCallback → onProgress → writeCallback → ファイル書き込みという流れが 1024 バイト単位で繰り返されます。
**デストラクタ（RAII）**ではスコープアウト時に cancel() + thread.join() が自動実行されるため、呼び出し側がスレッドの後始末を意識する必要がありません。

## 図② pause → resume
pause の仕組みは2段階です。まず compare_exchange で状態を DOWNLOADING → PAUSED にアトミックに遷移させ、pauseRequested_ = true を立てます。ワーカースレッドは次の writeCallback 呼び出し時にこのフラグを検出して condition_variable.wait() に入ります。CPU を消費しない真の待機です。
resume の仕組みは pauseCv_.notify_all() の1行で完結します。眠っているワーカーが即座に起き上がり onResumed() を通知して処理を継続します。sleep や polling は一切使いません。

## 図③ cancel / エラー / レジューム
cancel は curl コールバックの戻り値を使った優雅な中断です。cancelRequested_ = true を立てると、次の progressCallback で return 1（非ゼロ）を返し、curl 側が CURLE_ABORTED_BY_CALLBACK を発生させてダウンロードを止めます。呼び出し元はブロックせず即座に戻ります。
エラー はネットワーク障害と HTTP エラー（4xx/5xx）の2経路があります。perform() の戻り値と getHttpResponseCode() の両方をチェックすることで確実に捕捉します。
レジューム（新セッション）は startDownload() を再度呼ぶだけです。内部で既存ファイルのサイズを読んで CURLOPT_RESUME_FROM_LARGE に設定し、サーバに Range: bytes=N- ヘッダーを送ります。サーバが対応していれば HTTP 206 Partial Content が返り、downloadedBytes_ は resumeFrom から始まります。